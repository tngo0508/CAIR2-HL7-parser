commit 05e2ad9b33a2b15d21d0de5529149595504d72e2 (HEAD -> feature/enhancement-1, origin/feature/enhancement-1)
Author: Thomas Ngo <tngo0508@gmail.com>
Date:   Sun Feb 15 15:22:29 2026 -0800
    Enhance HL7 parser robustness and expand PID segment mapping
diff --git a/Hl7.Core/Hl7Parser.cs b/Hl7.Core/Hl7Parser.cs
index 5fd04d9..597ad09 100644
--- a/Hl7.Core/Hl7Parser.cs
+++ b/Hl7.Core/Hl7Parser.cs
@@ -28,8 +28,8 @@ public class Hl7Parser
     /// </summary>
     public Hl7Message ParseMessage(string hl7Message)
     {
-        if (string.IsNullOrWhiteSpace(hl7Message))
-            throw new ArgumentException("HL7 message cannot be null or empty");
+        if (string.IsNullOrEmpty(hl7Message))
+            return new Hl7Message();

         var message = new Hl7Message();
         var lines = hl7Message.Split(new[] { "\r\n", "\r", "\n" }, StringSplitOptions.RemoveEmptyEntries);
@@ -72,11 +72,14 @@ public class Hl7Parser
         // Extract separators from the MSH segment
         _separators = Hl7Separators.ParseFromMSH(segmentLine);

-        var fields = SplitFields(segmentLine, _separators.FieldSeparator);
+        // MSH is special. The field separator is the 4th character (index 3).
+        var fieldSeparator = segmentLine[3];

-        // HL7v2 MSH Special Case: After splitting by |, array indices are:
-        // [0] = "MSH", [1] = encoding chars, [2] = SendingApplication, [3] = SendingFacility, ...
-        // So we need to use [index+1] to get the right HL7 field
+        // In HL7, MSH is the only segment where the segment ID is followed immediately by the field separator,
+        // and that separator itself is MSH-1.
+        // segmentLine: "MSH|^~\\&|..."
+        // fields: ["MSH", "^~\\&", "...", ...]
+        var fields = segmentLine.Split(fieldSeparator);

         var mshSegment = new MSHSegment
         {
@@ -104,9 +107,10 @@ public class Hl7Parser
         };

         mshSegment.Fields = new Dictionary<int, string>();
+        mshSegment.Fields[1] = fieldSeparator.ToString(); // MSH-1 is the separator
         for (int i = 1; i < fields.Length; i++)
         {
-            mshSegment.Fields[i] = UnescapeField(fields[i]);
+            mshSegment.Fields[i + 1] = UnescapeField(fields[i]);
         }

         return mshSegment;
diff --git a/Hl7.Core/Segments/PIDSegment.cs b/Hl7.Core/Segments/PIDSegment.cs
index f94ae12..ba6a447 100644
--- a/Hl7.Core/Segments/PIDSegment.cs
+++ b/Hl7.Core/Segments/PIDSegment.cs
@@ -94,6 +94,72 @@ public class PIDSegment : Segment
     [DataElement(15, "Primary Language", ElementUsage.Optional)]
     public string PrimaryLanguage { get; set; } = string.Empty;

+    /// <summary>
+    /// Gets or sets the Marital Status (PID-16)
+    /// </summary>
+    [DataElement(16, "Marital Status", ElementUsage.Optional)]
+    public string MaritalStatus { get; set; } = string.Empty;
+
+    /// <summary>
+    /// Gets or sets the Religion (PID-17)
+    /// </summary>
+    [DataElement(17, "Religion", ElementUsage.Optional)]
+    public string Religion { get; set; } = string.Empty;
+
+    /// <summary>
+    /// Gets or sets the Patient Account Number (PID-18)
+    /// </summary>
+    [DataElement(18, "Patient Account Number", ElementUsage.Optional)]
+    public string PatientAccountNumber { get; set; } = string.Empty;
+
+    /// <summary>
+    /// Gets or sets the SSN Number - Patient (PID-19)
+    /// </summary>
+    [DataElement(19, "SSN Number - Patient", ElementUsage.Optional)]
+    public string SSNNumberPatient { get; set; } = string.Empty;
+
+    /// <summary>
+    /// Gets or sets the Ethnic Group (PID-22)
+    /// </summary>
+    [DataElement(22, "Ethnic Group", ElementUsage.Optional)]
+    public string EthnicGroup { get; set; } = string.Empty;
+
+    /// <summary>
+    /// Gets or sets the Birth Place (PID-23)
+    /// </summary>
+    [DataElement(23, "Birth Place", ElementUsage.Optional)]
+    public string BirthPlace { get; set; } = string.Empty;
+
+    /// <summary>
+    /// Gets or sets the Multiple Birth Indicator (PID-24)
+    /// </summary>
+    [DataElement(24, "Multiple Birth Indicator", ElementUsage.Optional)]
+    public string MultipleBirthIndicator { get; set; } = string.Empty;
+
+    /// <summary>
+    /// Gets or sets the Birth Order (PID-25)
+    /// </summary>
+    [DataElement(25, "Birth Order", ElementUsage.Optional)]
+    public string BirthOrder { get; set; } = string.Empty;
+
+    /// <summary>
+    /// Gets or sets the Citizenship (PID-26)
+    /// </summary>
+    [DataElement(26, "Citizenship", ElementUsage.Optional)]
+    public string Citizenship { get; set; } = string.Empty;
+
+    /// <summary>
+    /// Gets or sets the Last Update Date/Time (PID-33)
+    /// </summary>
+    [DataElement(33, "Last Update Date/Time", ElementUsage.Optional)]
+    public string LastUpdateDateTime { get; set; } = string.Empty;
+
+    /// <summary>
+    /// Gets or sets the Last Update Facility (PID-34)
+    /// </summary>
+    [DataElement(34, "Last Update Facility", ElementUsage.Optional)]
+    public string LastUpdateFacility { get; set; } = string.Empty;
+
     /// <summary>
     /// Initializes a new instance of the <see cref="PIDSegment"/> class
     /// </summary>
diff --git a/Hl7Test/RobustnessTests.cs b/Hl7Test/RobustnessTests.cs
new file mode 100644
index 0000000..4435837
--- /dev/null
+++ b/Hl7Test/RobustnessTests.cs
@@ -0,0 +1,148 @@
+using Hl7.Core;
+using Hl7.Core.Base;
+using Hl7.Core.Segments;
+using Hl7.Core.Common;
+
+namespace Hl7Test;
+
+public class RobustnessTests
+{
+    private readonly Hl7Parser _parser = new Hl7Parser();
+
+    [Fact]
+    public void Parse_Message_WithTrailingEmptyFields_ShouldNotThrow()
+    {
+        // Many HL7 messages have fewer fields than the maximum defined in the spec
+        string messageWithShortPID = "MSH|^~\\&|EMR|FAC||CAIR2|20230101||VXU^V04|123|P|2.5.1\nPID|1||12345";
+
+        var message = _parser.ParseMessage(messageWithShortPID);
+
+        Assert.NotNull(message);
+        var pid = message.GetSegment<PIDSegment>("PID");
+        Assert.NotNull(pid);
+        Assert.Equal("12345", pid.PatientIdentifierList);
+        Assert.Equal(string.Empty, pid.PatientName); // Optional field beyond provided data
+    }
+
+    [Fact]
+    public void Parse_Message_WithExtraFields_ShouldNotThrow()
+    {
+        // Extra fields should be ignored but captured in the generic Fields dictionary
+        string messageWithExtraFields = "MSH|^~\\&|EMR|FAC||CAIR2|20230101||VXU^V04|123|P|2.5.1\nPID|1||12345||DOE^JOHN||19800101|M|||||||||||||||||EXTRA_FIELD";
+
+        var message = _parser.ParseMessage(messageWithExtraFields);
+
+        Assert.NotNull(message);
+        var pid = message.GetSegment<PIDSegment>("PID");
+        Assert.NotNull(pid);
+        Assert.Equal("DOE^JOHN", pid.PatientName);
+        // Field 25 is beyond what PIDSegment normally maps, but should be in the dictionary if the parser works correctly
+        Assert.Equal("EXTRA_FIELD", pid.GetField(25));
+    }
+
+    [Fact]
+    public void Parse_Message_WithCustomSeparators_ShouldHandleCorrectly()
+    {
+        // Custom separators are allowed in HL7
+        // MSH followed by field separator '.', then encoding chars
+        string messageWithCustomSeparators = "MSH.~\\&.EMR.FAC..CAIR2.20230101..VXU^V04.123.P.2.5.1\nPID.1..12345";
+
+        // Note: Hl7Parser might need to be initialized with these or it might detect them.
+        // Looking at Hl7Parser.cs, it uses '|' by default. Let's see if it's robust.
+
+        var message = _parser.ParseMessage(messageWithCustomSeparators);
+
+        // If the parser isn't currently robust enough to detect separators from MSH automatically,
+        // this test might fail. That's good for identifying "robustness" gaps.
+        Assert.NotNull(message);
+        var msh = message.GetSegment<MSHSegment>("MSH");
+        Assert.Equal("EMR", msh.SendingApplication);
+    }
+
+    [Fact]
+    public void Parse_EmptyMessage_ShouldReturnEmptyHl7Message()
+    {
+        var message = _parser.ParseMessage("");
+        Assert.NotNull(message);
+        Assert.Empty(message.Segments);
+    }
+
+    [Fact]
+    public void Parse_MalformedMSH_ShouldReturnGenericSegments()
+    {
+        // If MSH is missing or malformed, it might not be parsed as MSHSegment but should still be parsed
+        string malformed = "XXX|1|2|3";
+        var message = _parser.ParseMessage(malformed);
+
+        Assert.NotNull(message);
+        Assert.Single(message.Segments);
+        Assert.Equal("XXX", message.Segments[0].SegmentId);
+    }
+
+    [Fact]
+    public void Parse_Message_WithEscapedCharacters_ShouldUnescape()
+    {
+        string messageWithEscapes = "MSH|^~\\&|EMR|FAC||CAIR2|20230101||VXU^V04|123|P|2.5.1\nPID|1||12345||DOE^JOHN\\F\\JR||19800101|M";
+
+        var message = _parser.ParseMessage(messageWithEscapes);
+
+        var pid = message.GetSegment<PIDSegment>("PID");
+        Assert.NotNull(pid);
+        // \F\ is field separator escape. If unescaped, it should be '|'
+        Assert.Equal("DOE^JOHN|JR", pid.PatientName);
+    }
+
+    [Fact]
+    public void Parse_EveryMappedField_MSH_Test()
+    {
+        string hl7 = "MSH|^~\\&|APP|FAC|RAPP|RFAC|202301011200|SEC|VXU^V04|MSGID|P|2.5.1|SEQ|CONT|ER|AL|CC|CHAR|LANG|SCHEME|PROFILE";
+        var message = _parser.ParseMessage(hl7);
+        var msh = message.GetSegment<MSHSegment>("MSH");
+
+        Assert.NotNull(msh);
+        Assert.Equal("^~\\&", msh.EncodingCharacters);
+        Assert.Equal("APP", msh.SendingApplication);
+        Assert.Equal("FAC", msh.SendingFacility);
+        Assert.Equal("RAPP", msh.ReceivingApplication);
+        Assert.Equal("RFAC", msh.ReceivingFacility);
+        Assert.Equal("202301011200", msh.MessageDateTime);
+        Assert.Equal("SEC", msh.Security);
+        Assert.Equal("VXU^V04", msh.MessageType);
+        Assert.Equal("MSGID", msh.MessageControlId);
+        Assert.Equal("P", msh.ProcessingId);
+        Assert.Equal("2.5.1", msh.VersionId);
+        Assert.Equal("SEQ", msh.SequenceNumber);
+        Assert.Equal("CONT", msh.ContinuationPointer);
+        Assert.Equal("ER", msh.AcceptAcknowledgmentType);
+        Assert.Equal("AL", msh.ApplicationAcknowledgmentType);
+        Assert.Equal("CC", msh.CountryCode);
+        Assert.Equal("CHAR", msh.CharacterSet);
+        Assert.Equal("LANG", msh.PrincipalLanguageOfMessage);
+        Assert.Equal("SCHEME", msh.AlternateCharacterSetHandlingScheme);
+        Assert.Equal("PROFILE", msh.MessageProfileIdentifier);
+    }
+
+    [Fact]
+    public void Parse_MultipleSegmentsOfSameType_ShouldAllBeAccessible()
+    {
+        string hl7 = "MSH|^~\\&|EMR|FAC||CAIR2|20230101||VXU^V04|123|P|2.5.1\nNK1|1|DOE^JANE|MTH\nNK1|2|DOE^JAMES|FTH";
+        var message = _parser.ParseMessage(hl7);
+
+        var nk1s = message.GetSegments<NK1Segment>("NK1");
+        Assert.Equal(2, nk1s.Count);
+        Assert.Equal("DOE^JANE", nk1s[0].Name);
+        Assert.Equal("DOE^JAMES", nk1s[1].Name);
+    }
+
+    [Fact]
+    public void Parse_InvalidNumericData_ShouldReturnZeroInsteadOfThrowing()
+    {
+        // PID-1 is an int. If we provide "ABC", it should be 0.
+        string hl7 = "MSH|^~\\&|EMR|FAC||CAIR2|20230101||VXU^V04|123|P|2.5.1\nPID|ABC||12345";
+        var message = _parser.ParseMessage(hl7);
+
+        var pid = message.GetSegment<PIDSegment>("PID");
+        Assert.NotNull(pid);
+        Assert.Equal(0, pid.SetId);
+    }
+}
